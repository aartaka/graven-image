#+TITLE:Graven Image

#+begin_quote
Thou shalt not make unto thee any graven image, or any likeness of any thing that is in heaven above, or that is in the earth beneath, or that is in the water under the earth.
#+end_quote

Graven Image is a Common Lisp portability library for better
interaction and debugging of a running Lisp image. One can inspect and
debug all the things under heaven and [[https://www.corecursive.com/lisp-in-space-with-ron-garret/][above it]]—all in their own
REPL-resident Lisp image!

Graven Image reuses compiler internals to improve/redefine the
existing standard functions. This "improvement" often comes at a cost
of changing the API of a function (for better customizability) or
making it slightly less reliable (due to unstable, compiler-internal,
or otherwise hacky implementation.)

The library is purposefully limited in scope:
- Improving the standard functions has a priority over introducing new
  ones.
  - [[https://github.com/m-n/repl-utilities][repl-utilities]] as a contrasting approach: it defines lots of
    "DWIM" functions, significantly altering the REPL interaction.
  - There are helpers like =function-lambda-list*=, but these are
    merely aliases/one-liners over standard/improved functions.
- The interaction paradigm of the improved functions should stay
  standard (i.e. use =*query-io*= where standard requires
  =*query-io*=.)
  - This is to ensure that libraries like [[https://github.com/atlas-engineer/ndebug/][Ndebug]] can rely on standard
    facilities safely when used with Graven Image.
- Function arglist can be modified for convenience, but it should
  preferably stay as close to standard/implementation-specific arglist
  as possible.
- Graven Image strives to not modify the REPL/image/shell in any way,
  relying on implementation defaults instead.
  - [[https://github.com/ciel-lang/CIEL][CIEL]] is taking a different direction: redefining the REPL for
    increased utility.


* Getting started

Clone the Git repository:
#+begin_src sh
  git clone --recursive https://github.com/aartaka/graven-image ~/common-lisp/
#+end_src

And then load ~:graven-image~ in the REPL:
#+begin_src lisp
  ;; Implies you have ASDF/Quicklisp and have Closer Mop and Trivial
  ;; Gray Streams accessible in ~/common-lisp/, Quicklisp local
  ;; projects, or ASDF registries.
  (asdf:load-system :graven-image)
  ;; or, if you use Quicklisp
  (ql:quickload :graven-image)
#+end_src

If you want your REPL to start with Graven Image constructs accessible
without package prefix, then add this to your implementation config file:
#+begin_src lisp
  (asdf:load-system :graven-image)
  ;; Imports external symbols of Graven Image into the current package
  ;; (CL-USER?) Safe, because Graven Image shadows no CL symbols.
  (use-package :graven-image)
#+end_src

* Enhanced functions (mostly from ANSI CL [[https://cl-community-spec.github.io/pages/Debugging-Utilities.html][Debugging Utilities]] chapter)

The functions that Graven Image exposes come in two flavors:
- Safely =:use=-able star-appended functions (i.e. =describe*= instead of
  =describe=)—in =graven-image= system.
- Functions shadowing CL symbols in =graven-image/cl= system.

All of the functions exposed by Graven Image are generics, so one can
easily define =:around= and other qualified methods for them.

** =y-or-n-p*=, =yes-or-no-p*= (generic functions)

Signature:
#+begin_src lisp
y-or-n-p* &optional control &rest arguments => generalized-boolean
yes-or-no-p* &optional control &rest arguments => generalized-boolean
#+end_src


Improvements are:
- Both functions accept options from =graven-image:*yes-or-no-options*=, thus
  allowing for "nope" or "ay" to be valid responses too.
- Both functions mean the same now, because it makes no sense in
  differentiating them.
- No beeps (just define a =yes-or-no-p* :before= method to add beeps
  if you like 'em; see the "Customization" section below).

** =apropos-list*=, =apropos*= (generic functions)

Signature:
#+begin_src lisp
apropos-list* string &optional (package nil) exported-only docs-too => list of symbols
apropos* string &optional (package nil) exported-only docs-too => no values
#+end_src

=apropos-list*= now allows listing exported symbols only (with
=exported-only=), which was a non-portable privilege of SBCL/Allegro
until now. Search over docs (more intuitive for =apropos(-list)*= than
mere name search) is possible with =docs-too=.

Based on this foundation, =apropos*= lists symbols with their types,
values, and documentation, so that implementation-specific formats are
gone for a better and more unified listing:

#+begin_src
> (apropos* :max)
MAX [FUNCTION (NUMBER &REST MORE-NUMBERS) : Return the greatest of its arguments; among EQUALP greatest, return...]
:MAX [SELF-EVALUATING]
...
SB-C::MAXREST
ALEXANDRIA:MAXF [MACRO : Modify-macro for MAX. Sets place designated by the first argument to the...]
...
SB-UNICODE::MAX-MATCH
SB-C::MAX-VOP-TN-REFS [CONSTANT: 256]
SB-LOOP::LOOP-MINIMAX [CLASS]
SB-IMPL::HEAP-MAXIMUM [FUNCTION (HEAP)]
...
#+end_src

** =function-lambda-expression*= (generic function)

Signature:
#+begin_src lisp
  function-lambda-expression* function/macro/method/symbol &optional force => list, list, symbol, list
  ;; Alias:
  lambda-expression* function/macro/method/symbol &optional force => list, list, symbol, list
#+end_src

This function tries to read source files, process the definitions of
functions, and build at least a barebones lambda from the arglist and
documentation of the function. So that CL =function-lambda-expression=
returns:
#+begin_src lisp
  (function-lambda-expression #'identity)
  ;; => NIL, T, IDENTITY
  (function-lambda-expression #'print-object)
  ;; => NIL, T, PRINT-OBJECT
#+end_src

While the new Graven Image =function-lambda-expression= now returns:
#+begin_src lisp
  (function-lambda-expression* #'idenitity)
  ;; => (LAMBDA (THING) "This function simply returns what was passed to it." THING),
  ;;    NIL, IDENTITY, (FUNCTION (T) (VALUES T &OPTIONAL))
  (function-lambda-expression* #'print-object t) ; Notice the T for FORCE, to build a dummy lambda.
  ;; => (LAMBDA (SB-PCL::OBJECT STREAM)), NIL, PRINT-OBJECT, (FUNCTION (T T) *)
#+end_src

Which means:
- =identity= is actually not a closure, and has a reliable source!
- =print-object= is a generic and thus is not really inspectable, so
  we build a dummy lambda for it when =force= argument is provided.
  - This might be a questionable choice, but it at least allows us to
    get function arglists from =function-lambda-expression= in a
    portable-ish way. The standard doesn't provide us with much ways
    to know an arglist of a function beside this.

*** Return values

Things that =function-lambda-expression*= now returns are:
- Lambda expression.
  - For lambda functions, their source.
  - For regular functions, their =defun= turned into a =lambda=.
  - For anything else, a constructed empty =(lambda (arglist...) documentation nil)= (only when =force= is T).
  - Or, in some exceptional cases, NIL.
- Whether the thing is a closure
  - If it is, might return an alist of the actual closed-over values,
    whenever accessible (not for all implementations).
  - If closed-over values are not accessible, returns T.
  - If it's not a closure, returns NIL.
- Function name. Mostly falls back to the standard
  =function-lambda-expression=, but also inspects
  implementation-specific function objects if necessary.
- Function type, whenever accessible.

*** Helpers

Based on these new features of =function-lambda-expression*=, here are
some Graven Image-specific helpers:
- =function-lambda-list*= :: Get the lambda list of a function.
  - =function-arglist*= :: Alias.
  - =lambda-list*= :: Alias for =function-lambda-list*=.
  - =arglist*= :: Alias.
- =function-name*= :: Get the name of a function.
- =function-type*= :: Get its ftype.

#+begin_src lisp
  function-lambda-list* function => lambda-list
  function-arglist* function => lambda-list
  lambda-list* function => lambda-list
  arglist* function => lambda-list
  function-name* function => name
  function-type* function => ftype
#+end_src


** =time*= (macro)

Signature:
#+begin_src lisp
time* &rest forms => values &rest return-values
#+end_src

The improved =time*= from Graven Image reuses as much
implementation-specific APIs as possible, with the predictable output
format.

And it also allows providing several forms, yay!

Most of this macro power relies on the power of:

*** =with-time*= (macro)

Signature:
#+begin_src lisp
with-time* (&rest time-keywords) (&rest multiple-value-args) form &body body
#+end_src


As the implementation detail of =time*=, =with-time*= allows to get
the timing data for interactive querying. =time-keywords= allow
=&key=-matching the timing data (like =:gc= time or bytes
=:allocated=) for processing in the body. While =multiple-value-args=
allow matching against the return values of the =form=. So we get best
of the both worlds: timing data and return values. This flexibility
enables =time*=, with its requirements of printing the data and
returning the original values at the same time.

** =describe*= (generic function)

Signature:
#+begin_src lisp
describe* object &optional (stream t) ignore-methods
#+end_src

Describes the =object= to the stream, but this time with portable
format of description (determined by =graven-image:description*= and
specified for many standard classes) and with predictable set of
properties (=graven-image:fields*=). In Graven Image, both
=describe= and =inspect= have the same format and the same set of
fields.

As an homage to the original =describe=, Graven Image one respects the
=describe-object= methods defined for user classes. If one needs to
ignore these too, passing T to =ignore-methods= should be enough to
get consistent Graven Image descriptions for all the objects.

*** =graven-image:fields*= (generic function)

Signature:
#+begin_src lisp
fields* object &key strip-null &allow-other-keys
#+end_src

Returns an undotted alist of properties for the =object=. Custom
fields provided by Graven Image are named with keywords, while the
implementation-specific ones use whatever the implementation
uses. Arrays and hash-tables are inlined into fields to allow
indexing these right from the inspector.

See =fields*= documentation for more details.

*** =graven-image:description*= (generic function)

Signature:
#+begin_src lisp
description* object &optional stream
#+end_src

Concise and informative description of =object= to the
=stream=. Useful information from most of the implementations
tested—united into one description header.
** =inspect*= (generic function)

Signature:
#+begin_src lisp
inspect* object &optional strip-null
#+end_src

New'n'shiny =inspect*= has:
- Most commands found in other implementation, with familiar names.
- Abbreviations like =H -> HELP= (inspired by SBCL).
- Ability to set object field values with =(:set key value)= command
  (inspired by CCL).
- Baked-in pagination with ways to scroll it (=:next-page=,
  =:previous-page=, =:home=) and change it (=:length=).
- Property indexing by both integer indices and property names (with
  abbreviations for them too!).
- Ability to ignore =nil= properties with =strip-null= argument
  (inspired by SBCL). On by default!
- And the ability to evaluate arbitrary expressions (with =:evaluate=
  command or simply by inputting something that doesn't match any
  command).

And here's a help menu of the new =inspect*= (in this case, inspecting
=*readtable*=), just to get you teased:

#+begin_src
This is an interactive interface for 5
Available commands are:
:?                            Show the instructions for using this interface.
:HELP                         Show the instructions for using this interface.
:QUIT                         Exit the interface.
:EXIT                         Exit the interface.
(:LENGTH NEW)                 Change the page size.
(:WIDTH NEW)                  Change the page size.
(:WIDEN NEW)                  Change the page size.
:NEXT                         Show the next page of fields (if any).
:PREVIOUS                     Show the previous page of fields (if any).
:PRINT                        Print the current page of fields.
:PAGE                         Print the current page of fields.
:HOME                         Scroll back to the first page of fields.
:RESET                        Scroll back to the first page of fields.
:TOP                          Scroll back to the first page of fields.
:THIS                         Show the currently inspected object.
:SELF                         Show the currently inspected object.
:REDISPLAY                    Show the currently inspected object.
:SHOW                         Show the currently inspected object.
:CURRENT                      Show the currently inspected object.
:AGAIN                        Show the currently inspected object.
(:EVAL EXPRESSION)            Evaluate the EXPRESSION.
:UP                           Go up to the previous level of the interface.
:POP                          Go up to the previous level of the interface.
:BACK                         Go up to the previous level of the interface.
(:SET KEY VALUE)              Set the KEY-ed field to VALUE.
(:MODIFY KEY VALUE)           Set the KEY-ed field to VALUE.
(:ISTEP KEY)                  Inspect the object under KEY.
(:INSPECT KEY)                Inspect the object under KEY.
:STANDARD                     Print the inspected object readably.
:AESTHETIC                    Print the inspected object aesthetically.

Possible inputs are:
- Mere symbols: run one of the commands above, matching the symbol.
  - If there's no matching command, then match against fields.
    - If nothing matches, evaluate the symbol.
- Integer: act on the field indexed by this integer.
  - If there are none, evaluate the integer.
- Any other atom: find the field with this atom as a key.
  - Evaluate it otherwise.
- S-expression: match the list head against commands and fields,
  as above.
  - If the list head does not match anything, evaluate the
    s-expression.
  - Inside this s-expression, you can use the `$' function to fetch
    the list of values under provided keys.
#+end_src

** =dribble*= (generic function)

Signature:
#+begin_src lisp
dribble* &optional pathname (if-exists :append)
#+end_src

Dribble the REPL session to =pathname=. Unlike the implementation-specific =dribble=, this one formats all of the session as =load=-able Lisp file fully reproducing the session. So all the input forms are printed verbatim, and all the outputs are commented out.

Beware: using any interactive function (like =inspect= etc.) breaks the dribble REPL. But then, it's unlikely one'd want to record interactive session into a dribble file.

** =documentation*= (generic function)

Signature:
#+begin_src lisp
  documentation* object &optional (doc-type t)
  doc* object &optional (doc-type t)
#+end_src

Improved version of =documentation=. Two main improvements are: =doc-type= is now optional, and =doc*= alias is available for convenience.

documentation.lisp also defines a method for =(symbol (eql t))=, which should simplify documentation fetching and setting.

* Customization

Graven Image is made to be extensible. That's why most of the improved functions are generic: one can define special methods for their data and patch the behavior with =:before=, =:after=, and =:around= methods. Most of Graven Image functions mention the variables/things influencing them in the docstring. Here's a set of useful customizations:

** Beeping before =yes-or-no-p*=

Restoring the standard-ish (beeping with bell (ASCII 7) character) behavior:
#+begin_src lisp
  (defmethod gimage:yes-or-no-p* :before (&optional control &rest arguments)
    (write-char (code-char 7) *query-io*)
    (finish-output *query-io*))
#+end_src

** Changing the accepted yes/no options for =yes-or-no-p*= and =y-or-n-p*=
#+begin_src lisp
  ;; Make it strict yes/no as per standard.
  (defmethod gimage:yes-or-no-p* :around (&optional control &rest arguments)
    (let ((gimage:*yes-or-no-options*
            '(("yes" . t)
              ("no" . nil))))
      (call-next-method)))

  ;; Add more yes/no options (Russian, for example).
  (defmethod gimage:y-or-n-p* :around (&optional control &rest arguments)
    (let ((gimage:*yes-or-no-options*
            (append
             gimage:*yes-or-no-options*
             '(("да" . t)
               ("ага" . t)
               ("нет" . nil)
               ("не" . nil)
               ("неа" . nil)))))
      (call-next-method)))
#+end_src

** Sorting =apropos-list*= lists

Implementations are not good at sorting things, and their results are
not often useful. Sorting things the way one needs is a useful
extension. Here's a simple yet effective =:around= method that sorts
things by =string= occurence:
#+begin_src lisp
  (defmethod gimage:apropos-list* :around (string &optional packages external-only docs-too)
    "Sort symbols by the relation of subSTRING count to the length of symbol."
    (declare (ignorable packages external-only docs-too))
    (let ((result (call-next-method)))
      (sort
       (remove-duplicates result)
       ;; For more comprehensive matching, see
       ;; a1b4ebd649e0268b1566e80709e7cea41363d006 and other commits
       ;; before c090d6dc14e05c561cf5c39cf5f6cc02e8cd04c5.
       #'> :key (lambda (sym)
                  (let ((match-count 0))
                    (uiop:frob-substrings
                     (string sym) (list (string string))
                     (lambda (sub frob)
                       (incf match-count)
                       (funcall frob sub)))
                    (/ match-count (length (string sym))))))))
#+end_src

** Changing printer settings for Graven Image output

TODO!

* Roadmap
- [ ] Add:
  - [X] =apropos*=, =apropos-list*=
    - [X] Add a way to sort symbols by relevance/name match.
  - [X] =inspect*=,
  - [X] =describe*=,
  - [X] =time*=,
  - [ ] =ed*=.
- [ ] Improve
  - [X] =dribble=,
    - [ ] Make dribble file prettier, strip off the REPL prompt.
    - [ ] Support ABCL somehow.
  - [ ] =step=,
  - [ ] =trace= and =untrace=
  - [X] =documentation=?
  - [ ] =disassemble=?
  - [ ] =room=?
- [X] Somehow hook into and improve over =*debugger-hook*=?
  - Use Ndebug for that.
- [ ] Test on more implementations.
- [ ] Maybe add an interactive file manager?
  - Yes, this is beyond the goal of nice portable standard debugging
    facilities that Graven Image pursues. But it kinda is intuitive,
    and most implementations have some form of directory switching and
    other file operations.
    - And there's a reasonably big portable file API in ANSI CL.
